"""
Demo script showing the SQL Agent workflow without requiring API keys.
This demonstrates the database setup and SQL execution parts.
"""

import sqlite3
import requests
from typing import Dict, Any


class SQLAgentDemo:
    """A demonstration of the SQL agent's database capabilities."""
    
    def __init__(self):
        """Initialize the demo agent."""
        self.db_connection = None
        self.schema_info = ""
        self._setup_database()
        
    def _setup_database(self):
        """Fetch Chinook database SQL and set up in-memory database."""
        print("Setting up Chinook database...")
        
        # Fetch the SQL file
        url = "https://raw.githubusercontent.com/lerocha/chinook-database/master/ChinookDatabase/DataSources/Chinook_Sqlite.sql"
        response = requests.get(url)
        response.raise_for_status()
        sql_content = response.text
        
        # Create in-memory database
        self.db_connection = sqlite3.connect(":memory:")
        cursor = self.db_connection.cursor()
        
        # Execute the SQL to create tables and insert data
        cursor.executescript(sql_content)
        self.db_connection.commit()
        
        # Extract schema information
        self.schema_info = self._get_schema_info()
        print("Database setup complete!")
        
    def _get_schema_info(self) -> str:
        """Extract detailed schema information from the database."""
        cursor = self.db_connection.cursor()
        
        # Get all tables
        cursor.execute("SELECT name FROM sqlite_master WHERE type='table';")
        tables = cursor.fetchall()
        
        schema_parts = []
        for table in tables:
            table_name = table[0]
            
            # Get table schema
            cursor.execute(f"PRAGMA table_info({table_name})")
            columns = cursor.fetchall()
            
            # Get sample data (first 3 rows)
            cursor.execute(f"SELECT * FROM {table_name} LIMIT 3")
            sample_data = cursor.fetchall()
            
            schema_part = f"\nTable: {table_name}\n"
            schema_part += "Columns:\n"
            for col in columns:
                schema_part += f"  - {col[1]} ({col[2]}) {'PRIMARY KEY' if col[5] else ''} {'NOT NULL' if col[3] else ''}\n"
            
            if sample_data:
                schema_part += f"Sample data (first 3 rows):\n"
                col_names = [col[1] for col in columns]
                schema_part += f"  {' | '.join(col_names)}\n"
                for row in sample_data:
                    schema_part += f"  {' | '.join(str(x) if x is not None else 'NULL' for x in row)}\n"
            
            schema_parts.append(schema_part)
        
        return "\n".join(schema_parts)
    
    def execute_sql(self, sql_query: str) -> str:
        """Execute a SQL query and return formatted results."""
        try:
            cursor = self.db_connection.cursor()
            cursor.execute(sql_query)
            results = cursor.fetchall()
            
            # Get column names
            column_names = [description[0] for description in cursor.description]
            
            # Format results
            if not results:
                return "No results found."
            else:
                result_lines = [" | ".join(column_names)]
                result_lines.append("-" * len(result_lines[0]))
                for row in results:
                    result_lines.append(" | ".join(str(x) if x is not None else "NULL" for x in row))
                return "\n".join(result_lines)
                
        except Exception as e:
            return f"SQL execution error: {str(e)}"
    
    def demo_queries(self):
        """Demonstrate various SQL queries."""
        # Predefined SQL queries that would be generated by the LLM
        demo_queries = [
            {
                "question": "How many customers are there?",
                "sql": "SELECT COUNT(*) FROM Customer",
                "explanation": "Count all customers in the database"
            },
            {
                "question": "Who are the top 5 customers by total purchases?",
                "sql": "SELECT c.FirstName, c.LastName, SUM(i.Total) as TotalSpent FROM Customer c JOIN Invoice i ON c.CustomerId = i.CustomerId GROUP BY c.CustomerId ORDER BY TotalSpent DESC LIMIT 5",
                "explanation": "Find customers with highest total purchases"
            },
            {
                "question": "What are the most popular music genres?",
                "sql": "SELECT g.Name, COUNT(t.TrackId) as TrackCount FROM Genre g JOIN Track t ON g.GenreId = t.GenreId GROUP BY g.GenreId ORDER BY TrackCount DESC LIMIT 10",
                "explanation": "Count tracks per genre to find most popular"
            },
            {
                "question": "Which artists have the most albums?",
                "sql": "SELECT ar.Name, COUNT(al.AlbumId) as AlbumCount FROM Artist ar JOIN Album al ON ar.ArtistId = al.ArtistId GROUP BY ar.ArtistId ORDER BY AlbumCount DESC LIMIT 10",
                "explanation": "Count albums per artist"
            },
            {
                "question": "How many tracks are there in the Rock genre?",
                "sql": "SELECT COUNT(t.TrackId) FROM Track t JOIN Genre g ON t.GenreId = g.GenreId WHERE g.Name = 'Rock'",
                "explanation": "Count tracks in Rock genre"
            },
            {
                "question": "What are the longest tracks?",
                "sql": "SELECT t.Name, ar.Name as Artist, t.Milliseconds FROM Track t JOIN Album al ON t.AlbumId = al.AlbumId JOIN Artist ar ON al.ArtistId = ar.ArtistId ORDER BY t.Milliseconds DESC LIMIT 10",
                "explanation": "Find tracks with longest duration"
            }
        ]
        
        print("\n" + "="*60)
        print("SQL AGENT DEMONSTRATION")
        print("="*60)
        print("This shows how the LangGraph-based text-to-SQL agent works:")
        print("1. User asks a natural language question")
        print("2. Agent generates appropriate SQL query")
        print("3. Agent executes the query against the database")
        print("4. Agent formats and presents the results")
        print("="*60 + "\n")
        
        for i, demo in enumerate(demo_queries, 1):
            print(f"EXAMPLE {i}:")
            print(f"Question: {demo['question']}")
            print(f"Generated SQL: {demo['sql']}")
            print(f"Explanation: {demo['explanation']}")
            print("\nQuery Results:")
            
            result = self.execute_sql(demo['sql'])
            print(result)
            print("\n" + "-"*50 + "\n")
    
    def get_database_summary(self):
        """Get a summary of the database contents."""
        cursor = self.db_connection.cursor()
        
        print("DATABASE SUMMARY:")
        print("================")
        
        # Get all tables and their row counts
        cursor.execute("SELECT name FROM sqlite_master WHERE type='table';")
        tables = cursor.fetchall()
        
        for table in tables:
            table_name = table[0]
            cursor.execute(f"SELECT COUNT(*) FROM {table_name}")
            count = cursor.fetchone()[0]
            print(f"- {table_name}: {count} rows")
        
        print(f"\nTotal tables: {len(tables)}")


def main():
    """Run the demo."""
    print("LangGraph Text-to-SQL Agent Demo")
    print("================================\n")
    
    # Create demo agent
    demo = SQLAgentDemo()
    
    # Show database summary
    demo.get_database_summary()
    
    # Show demo queries
    demo.demo_queries()
    
    print("AGENT ARCHITECTURE:")
    print("==================")
    print("The complete LangGraph agent uses the following workflow:")
    print("1. üß† SQL Generation Node: Converts natural language to SQL")
    print("2. üîç SQL Execution Node: Runs the query against the database")
    print("3. üìù Response Generation Node: Creates natural language responses")
    print("4. üîÑ Conditional Logic: Routes between nodes based on state")
    print("5. ‚ùå Error Handling: Manages invalid queries and irrelevant questions")
    print("\nFeatures:")
    print("- Uses detailed database schema in prompts for accurate SQL generation")
    print("- Handles irrelevant questions by responding 'I don't know'")
    print("- Provides natural language responses to query results")
    print("- Built with LangGraph for robust state management")
    print("- Supports both OpenAI and Claude language models")


if __name__ == "__main__":
    main()